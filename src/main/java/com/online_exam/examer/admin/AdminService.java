package com.online_exam.examer.admin;


import com.online_exam.examer.admin.request.*;
import com.online_exam.examer.authentication.EmailService;
import com.online_exam.examer.exam.ExamEntity;
import com.online_exam.examer.exam.ExamRepository;
import com.online_exam.examer.exception.AlreadyExsistsException;
import com.online_exam.examer.exception.PasswordNotMatchedException;
import com.online_exam.examer.exception.ResourceNotFoundException;
import com.online_exam.examer.mapper.EntityToDtoMapper;
import com.online_exam.examer.mapper.PageDto;
import lombok.RequiredArgsConstructor;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class AdminService implements IAdminService{

    private final AdminRepository adminRepository;
    private final EntityToDtoMapper entityToDtoMapper;
    private final BCryptPasswordEncoder bCryptPasswordEncoder;
    private final PasswordGenerator passwordGenerator;
    private final EmailService emailService;
    private final ExamRepository examRepository;

    @Transactional
    @Override
    public void addAdmin(AddAdminRequest addAdminRequest) {
        // Check if an admin with the same username already exists

        if (adminRepository.existsByAdminUserName(addAdminRequest.getAdminUserName())&& adminRepository.existsByAdminUserNameAndIsDeletedFalse(addAdminRequest.getAdminUserName())) {
            throw new AlreadyExsistsException("the admin with this username already exists");
        }

        if (adminRepository.existsByAdminUserNameAndIsDeletedTrue(addAdminRequest.getAdminUserName())) {
            throw new AlreadyExsistsException("the admin with this username already exists And Deleted You can Recover It Again Or Delete It Permanently");
        }
        // Check if an admin with the same email already exists
        if (adminRepository.existsByEmail(addAdminRequest.getEmail())&& adminRepository.existsByEmailAndIsDeletedFalse(addAdminRequest.getEmail())) {
            throw new AlreadyExsistsException("the admin with this email already exists");
        }

        if (adminRepository.existsByEmailAndIsDeletedTrue(addAdminRequest.getEmail())) {
            throw new AlreadyExsistsException("the admin with this email already exists And Deleted You can Recover It Again Or Delete It Permanently");
        }

        // Map the request to an AdminEntity
        AdminEntity adminEntity = new AdminEntity();
        adminEntity.setAdminUserName(addAdminRequest.getAdminUserName());
        adminEntity.setPhone(addAdminRequest.getPhone());
        adminEntity.setEmail(addAdminRequest.getEmail());
        final String pass = passwordGenerator.generateRandomPassword();
        adminEntity.setPassword(bCryptPasswordEncoder.encode(pass));
        adminEntity.setRole("admin");//to send admin static
        //adminEntity.setRole(addAdminRequest.getRole());//if you need to send admin role

        // Save the new admin to the database
        AdminEntity savedAdmin = adminRepository.save(adminEntity);
        //send atuo generated password to the user
        emailService.sendAutoGeneratedPassword(savedAdmin.getEmail(), pass, savedAdmin.getAdminUserName());

    }

    @Transactional
    @Override
    public SuperAdminResponse addSuperAdmin(AddAdminRequest addAdminRequest) {
        // Check if an admin with the same username already exists

        if (adminRepository.existsByRole("super_admin")) {
            throw new AlreadyExsistsException("Super Admin already exists.");
        }

        if (adminRepository.existsByAdminUserName(addAdminRequest.getAdminUserName())&& adminRepository.existsByAdminUserNameAndIsDeletedFalse(addAdminRequest.getAdminUserName())) {
            throw new AlreadyExsistsException("the admin with this username already exists");
        }

        if (adminRepository.existsByAdminUserNameAndIsDeletedTrue(addAdminRequest.getAdminUserName())) {
            throw new AlreadyExsistsException("the admin with this username already exists And Deleted You can Recover It Again Or Delete It Permanently");
        }
        // Check if an admin with the same email already exists
        if (adminRepository.existsByEmail(addAdminRequest.getEmail())&& adminRepository.existsByEmailAndIsDeletedFalse(addAdminRequest.getEmail())) {
            throw new AlreadyExsistsException("the admin with this email already exists");
        }

        if (adminRepository.existsByEmailAndIsDeletedTrue(addAdminRequest.getEmail())) {
            throw new AlreadyExsistsException("the admin with this email already exists And Deleted You can Recover It Again Or Delete It Permanently");
        }

        // Map the request to an AdminEntity
        AdminEntity adminEntity = new AdminEntity();
        adminEntity.setAdminUserName(addAdminRequest.getAdminUserName());
        adminEntity.setPhone(addAdminRequest.getPhone());
        adminEntity.setEmail(addAdminRequest.getEmail());
        final String pass = passwordGenerator.generateRandomPassword();
        adminEntity.setPassword(bCryptPasswordEncoder.encode(pass));
        adminEntity.setRole("super_admin");//to send admin static
        //adminEntity.setRole(addAdminRequest.getRole());//if you need to send admin role

        // Save the new admin to the database
        AdminEntity savedAdmin = adminRepository.save(adminEntity);
        //send atuo generated password to the user
        //emailService.sendAutoGeneratedPassword(savedAdmin.getEmail(), pass, savedAdmin.getAdminUserName());

        return  new SuperAdminResponse(addAdminRequest.getAdminUserName(),pass);

    }

    @Transactional
    @Override
    public PageDto<AdminDto> deleteAdminById(Long adminId, Pageable pageable) {
        // Check if the admin with the given ID exists
        if (!adminRepository.existsById(adminId)) {
            throw new ResourceNotFoundException("The requested admin is not available.");
        }

        AdminEntity adminEntity = adminRepository.findById(adminId).get();

        // Soft delete users related to the admin
        if (adminEntity.getUser() != null) {
            adminEntity.getUser().forEach(user -> {
                // Mark the user as deleted (soft delete)
                user.setDeleted(true);
            });
        }

        List<ExamEntity> examEntities = examRepository.findAllByAdmin_AdminId(adminId);
        examRepository.deleteAll(examEntities);


        // Soft delete the admin itself
        adminEntity.setDeleted(true);

        // Save the updated admin entity with the soft delete flag set
        adminRepository.save(adminEntity);

        // Retrieve the updated list of all remaining admins, excluding the soft-deleted ones
        Page<AdminEntity> adminEntitiesPage = adminRepository.findAllByRoleAndIsDeletedFalse("admin", pageable);

        // Map the Page<AdminEntity> to Page<AdminDto> using your entity-to-DTO mapper
        Page<AdminDto> adminsPage = entityToDtoMapper.adminsPageToDtoPage(adminEntitiesPage);

        // Map AdminDto to PageDto to return only the required data (avoid serialization issues)
        return new PageDto<>(adminsPage);
    }





    @Transactional(readOnly = true)
    @Override
    public PageDto<AdminDto> getAdminsByRole(String role, Pageable pageable) {

        // Check if any admins exist with the given role
        if (!adminRepository.existsByRole(role)) {
            throw new ResourceNotFoundException("No admins found with the specified role.");
        }


        //find admins by role and map whole of entity into page of admin entity
      //  Page<AdminEntity> adminEntitiesPage = adminRepository.findAllByRole(role, pageable);

        //find admins by role and map whole of entity into page of admin entity
        Page<AdminEntity> adminEntitiesPage = adminRepository.findAllByRoleAndIsDeletedFalse(role, pageable);

        // Use the mapper to convert Page<AdminEntity> to Page<AdminDto>

         Page<AdminDto> adminsPage = entityToDtoMapper.adminsPageToDtoPage(adminEntitiesPage);

         //map AdminDto to Page Dto to avoid serialization and return only data we need
         return new PageDto<>(adminsPage);


    }
    @Transactional(readOnly = true)
    @Override
    public PageDto<AdminDto> getDeletedAdmins(String role, Pageable pageable) {

        // Check if any admins exist with the given role
        if (!adminRepository.existsByRole(role)) {
            throw new ResourceNotFoundException("No admins found with the specified role.");
        }


        //find admins by role and map whole of entity into page of admin entity
      //  Page<AdminEntity> adminEntitiesPage = adminRepository.findAllByRole(role, pageable);

        //find admins by role and map whole of entity into page of admin entity
        Page<AdminEntity> adminEntitiesPage = adminRepository.findAllByRoleAndIsDeletedTrue(role, pageable);

        // Use the mapper to convert Page<AdminEntity> to Page<AdminDto>

         Page<AdminDto> adminsPage = entityToDtoMapper.adminsPageToDtoPage(adminEntitiesPage);

         //map AdminDto to Page Dto to avoid serialization and return only data we need
         return new PageDto<>(adminsPage);


    }


    @Transactional
    @Override
    public PageDto<AdminDto> hardDeleteAdmin(Long adminId,Pageable pageable) {
        // Check if the admin with the given ID exists
        if (!adminRepository.existsById(adminId)) {
            throw new ResourceNotFoundException("The requested admin is not available." );
        }
        // Delete the admin
        adminRepository.deleteById(adminId);



        // Retrieve the updated list of all remaining admins

        //find admins by role and map whole of entity into page of admin entity
        Page<AdminEntity> adminEntitiesPage = adminRepository.findAllByRoleAndIsDeletedTrue("admin", pageable);

        // Use the mapper to convert Page<AdminEntity> to Page<AdminDto>

        Page<AdminDto> adminsPage = entityToDtoMapper.adminsPageToDtoPage(adminEntitiesPage);

        //map AdminDto to Page Dto to avoid serialization and return only data we need
        return new PageDto<>(adminsPage);


    }

    @Transactional
    @Override
    public PageDto<AdminDto> recoverAdmin(RecoverAdminRequest recoverAdminRequest, Pageable pageable) {
        // Check if the admin with the given ID exists
        if (!adminRepository.existsById(recoverAdminRequest.getAdminId())) {
            throw new ResourceNotFoundException("The requested admin is not available." );
        }

        AdminEntity adminEntity = adminRepository.findById(recoverAdminRequest.getAdminId()).get();


        if (adminEntity.getUser() != null) {
            adminEntity.getUser().forEach(user -> {
                        // Mark the user as deleted
                        user.setDeleted(false);
                    }
            );

        }


        adminEntity.setDeleted(false);

        adminRepository.save(adminEntity);


        // Retrieve the updated list of all remaining admins

        //find admins by role and map whole of entity into page of admin entity
        Page<AdminEntity> adminEntitiesPage = adminRepository.findAllByRoleAndIsDeletedTrue("admin", pageable);

        // Use the mapper to convert Page<AdminEntity> to Page<AdminDto>

        Page<AdminDto> adminsPage = entityToDtoMapper.adminsPageToDtoPage(adminEntitiesPage);

        //map AdminDto to Page Dto to avoid serialization and return only data we need
        return new PageDto<>(adminsPage);


    }




    @Transactional
    @Override
    public void updateAdminPasswordById(Long adminId, UpdateAdminPasswordRequest updateAdminPasswordRequest) {
        // Check if the admin with the given ID exists
        if (!adminRepository.existsById(adminId)) {
            throw new ResourceNotFoundException("The requested admin could not be found.");
        }

        // Retrieve the admin entity
        AdminEntity updateAdminEntity = adminRepository.findById(adminId).get(); // Safe to use get() after existence check

        if(!bCryptPasswordEncoder.matches(updateAdminPasswordRequest.getOldPassword(), updateAdminEntity.getPassword())){
            throw new PasswordNotMatchedException("Current password doesn't matched");
        }

        if(bCryptPasswordEncoder.matches(updateAdminPasswordRequest.getNewPassword(), updateAdminEntity.getPassword())){
            throw new PasswordNotMatchedException("New Password Can't Matches Current password");
        }

        updateAdminEntity.setPassword(bCryptPasswordEncoder.encode(updateAdminPasswordRequest.getNewPassword()));

        // Save the updated admin entity back to the database
        adminRepository.save(updateAdminEntity);

    }


    @Transactional
    @Override
    public AdminDto updateAdminInfoById(Long adminId, UpdateAdminInfoRequest updateAdminInfoRequest) {
        // Check if the admin with the given ID exists
        if (!adminRepository.existsById(adminId)) {
            throw new ResourceNotFoundException("The requested admin could not be found.");
        }

        // Retrieve the admin entity
        AdminEntity updateAdminEntity = adminRepository.findById(adminId).get(); // Safe to use get() after existence check

        // Check if an admin with the same username already exists, excluding the current admin
        if (adminRepository.existsByAdminUserName(updateAdminInfoRequest.getAdminUserName())
                && !updateAdminEntity.getAdminUserName().equals(updateAdminInfoRequest.getAdminUserName())) {
            throw new AlreadyExsistsException("An admin with this username already exists");
        }

        // Check if an admin with the same email already exists, excluding the current admin
        if (adminRepository.existsByEmail(updateAdminInfoRequest.getEmail())
                && !updateAdminEntity.getEmail().equals(updateAdminInfoRequest.getEmail())) {
            throw new AlreadyExsistsException("An admin with this email already exists");
        }


        // Update fields of the admin entity
        updateAdminEntity.setAdminUserName(updateAdminInfoRequest.getAdminUserName());
        updateAdminEntity.setEmail(updateAdminInfoRequest.getEmail());
        updateAdminEntity.setPhone(updateAdminInfoRequest.getPhone());


        // Save the updated admin entity back to the database
       AdminEntity updatedAdmin= adminRepository.save(updateAdminEntity);

       return entityToDtoMapper.adminToDto(updatedAdmin);


    }

    @Transactional(readOnly = true)
    @Override
    public AdminDto getAdminById(Long adminId) {
        // Check if the admin with the given ID exists
        if (!adminRepository.existsById(adminId)) {
            throw new ResourceNotFoundException("The requested admin could not be found.");
        }

        // Retrieve the admin by ID
        AdminEntity admin = adminRepository.findById(adminId).get(); // Use get() since we checked existence

        return entityToDtoMapper.adminToDto(admin);
    }

    @Override
    public boolean isAdminDeleted(String adminUsername) {
        return adminRepository.existsByAdminUserNameAndIsDeletedTrue(adminUsername);
    }


    public void updatePassword(String adminEmail, String newPassword) {

        if (adminRepository.existsByEmail(adminEmail)) {
            AdminEntity admin = adminRepository.findByEmail(adminEmail);
            admin.setPassword(bCryptPasswordEncoder.encode(newPassword)); // Hash the new password
            adminRepository.save(admin);
        }
    }


    /*********************** Not Used Services *****************************/

//
//    @Override
//    public AdminDto updateAdminPasswordById(Long adminId, UpdateAdminPasswordRequest updateAdminPasswordRequest) {
//        // Check if the admin with the given ID exists
//        if (!adminRepository.existsById(adminId)) {
//            throw new ResourceNotFoundException("Admin not found with ID: " + adminId);
//        }
//
//        // Retrieve the admin entity
//        AdminEntity updateAdminEntity = adminRepository.findById(adminId).get(); // Safe to use get() after existence check
//
//        if(!bCryptPasswordEncoder.matches(updateAdminPasswordRequest.getOldPassword(), updateAdminEntity.getPassword())){
//            throw new PasswordNotMatchedException("Current password doesn't matched");
//        }
//
//        if(bCryptPasswordEncoder.matches(updateAdminPasswordRequest.getNewPassword(), updateAdminEntity.getPassword())){
//            throw new PasswordNotMatchedException("New Password Can't Matches Current password");
//        }
//
//        updateAdminEntity.setPassword(bCryptPasswordEncoder.encode(updateAdminPasswordRequest.getNewPassword()));
//
//        // Save the updated admin entity back to the database
//        AdminEntity savedAdmin = adminRepository.save(updateAdminEntity);
//
//        return entityToDtoMapper.adminToDto(savedAdmin);
//    }

//
//    @Transactional
//    @Override
//    public PageDto<AdminDto> updateAdminInfoBySuperAdminById(Long adminId, UpdateAdminInfoRequest updateAdminInfoRequest, Pageable pageable) {
//        // Check if the admin with the given ID exists
//        if (!adminRepository.existsById(adminId)) {
//            throw new ResourceNotFoundException("The requested admin could not be found.");
//        }
//
//        // Retrieve the admin entity
//        AdminEntity updateAdminEntity = adminRepository.findById(adminId).get(); // Safe to use get() after existence check
//
//        // Check if an admin with the same username already exists, excluding the current admin
//        if (adminRepository.existsByAdminUserName(updateAdminInfoRequest.getAdminUserName())
//                && !updateAdminEntity.getAdminUserName().equals(updateAdminInfoRequest.getAdminUserName())) {
//            throw new AlreadyExsistsException("An admin with this username already exists");
//        }
//
//// Check if an admin with the same email already exists, excluding the current admin
//        if (adminRepository.existsByEmail(updateAdminInfoRequest.getEmail())
//                && !updateAdminEntity.getEmail().equals(updateAdminInfoRequest.getEmail())) {
//            throw new AlreadyExsistsException("An admin with this email already exists");
//        }
//
//
//        // Update fields of the admin entity
//        updateAdminEntity.setAdminUserName(updateAdminInfoRequest.getAdminUserName());
//        updateAdminEntity.setEmail(updateAdminInfoRequest.getEmail());
//        updateAdminEntity.setPhone(updateAdminInfoRequest.getPhone());
//
//
//        // Save the updated admin entity back to the database
//        adminRepository.save(updateAdminEntity);
//
//        //find admins by role and map whole of entity into page of admin entity
//        Page<AdminEntity> adminEntitiesPage = adminRepository.findAllByRoleAndIsDeletedFalse("admin", pageable);
//
//        // Use the mapper to convert Page<AdminEntity> to Page<AdminDto>
//
//        Page<AdminDto> adminsPage = entityToDtoMapper.adminsPageToDtoPage(adminEntitiesPage);
//
//        //map AdminDto to Page Dto to avoid serialization and return only data we need
//        return new PageDto<>(adminsPage);
//    }




}
